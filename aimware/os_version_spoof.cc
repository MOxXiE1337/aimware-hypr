#include "aimware.h"

#include <hyprtrace/exec_tracer.h>

std::unordered_map<uintptr_t, bool> g_os_version_number_addresses_spoofed;


#define SPOOF_OS_VER(address, len, reg)\
if(!hyprtrace::ExecutionTracer::AddExecutionBreakPoint(address, len, {}, [](hyprutils::LogManager* logman, PCONTEXT context)\
	{\
		if(context->reg == *reinterpret_cast<uint32_t*>(0x7FFE0260))\
		{\
			context->reg = 0x4A65;\
		}\
		if(g_os_version_number_addresses_spoofed.find(address) == g_os_version_number_addresses_spoofed.end())\
		{\
			g_os_version_number_addresses_spoofed[address] = true;\
			logman->Log("spoofed os version number {:X} ({}/{})", address, g_os_version_number_addresses_spoofed.size(), 64);\
		}\
	}))\
{\
	return false;\
}\

bool Aimware::SetupOSVersionSpoof()
{
	hyprutils::LogManager& logman = GetLogManager();
	if (IsBadReadPtr(reinterpret_cast<const void*>(0x7FFE0260), sizeof(uint32_t)))
	{
		logman.Log("KUSER_SHARED_DATA memory region is invalid, trying to allocate...");
		if (!VirtualAlloc(reinterpret_cast<void*>(0x7FFE0260), 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE))
		{
			logman.Error("failed to allocate memory at 7FFE0260 for KUSER_SHARED_DATA");
			return false;
		}
	}
	SPOOF_OS_VER(0x00000011B7949D32, 0x4, R10);
	SPOOF_OS_VER(0x00000011B8114A0E, 0x4, Rax);
	SPOOF_OS_VER(0x00000011B807CD12, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B78B971F, 0x7, Rcx);
	SPOOF_OS_VER(0x00000011B7E06841, 0x4, Rsi);
	SPOOF_OS_VER(0x00000011B81093BA, 0x7, Rbx);
	SPOOF_OS_VER(0x00000011B8114119, 0x4, Rdi);
	SPOOF_OS_VER(0x00000011B79DD859, 0x4, Rdi);
	SPOOF_OS_VER(0x00000011B7899220, 0x7, Rax);
	SPOOF_OS_VER(0x00000011B7A5421E, 0x8, Rcx);
	SPOOF_OS_VER(0x00000011B7FF07B4, 0x3, Rdi);
	SPOOF_OS_VER(0x00000011B79C6412, 0x7, Rsi);
	SPOOF_OS_VER(0x00000011B759A696, 0x8, R10);
	SPOOF_OS_VER(0x00000011B80D976E, 0x8, Rdi);
	SPOOF_OS_VER(0x00000011B785F975, 0x7, Rsi);
	SPOOF_OS_VER(0x00000011B7903EF1, 0x8, Rcx);
	SPOOF_OS_VER(0x00000011B78BA1F2, 0x8, R10);
	SPOOF_OS_VER(0x00000011B784575A, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B78B377E, 0x3, Rdx);
	SPOOF_OS_VER(0x00000011B78E3CBC, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B7F23C94, 0x8, R8);
	SPOOF_OS_VER(0x00000011B7F79411, 0x4, Rsi);
	SPOOF_OS_VER(0x00000011B7A80762, 0x5, Rdi);
	SPOOF_OS_VER(0x00000011B80DCF18, 0x8, Rdi);
	SPOOF_OS_VER(0x00000011B7AFF7F5, 0x7, Rbp);
	SPOOF_OS_VER(0x00000011B8036FE2, 0x3, Rax);
	SPOOF_OS_VER(0x00000011B7574CB4, 0x8, Rcx);
	SPOOF_OS_VER(0x00000011B7AD2729, 0x3, Rbp);
	SPOOF_OS_VER(0x00000011B7BC6422, 0x7, Rsi);
	SPOOF_OS_VER(0x00000011B78B8BAC, 0x4, Rdx);
	SPOOF_OS_VER(0x00000011B78B45A9, 0x5, Rdx);
	SPOOF_OS_VER(0x00000011B8087297, 0x7, Rbp);
	SPOOF_OS_VER(0x00000011B7A73959, 0x8, R8);
	SPOOF_OS_VER(0x00000011B7ABAF06, 0x8, R10);
	SPOOF_OS_VER(0x00000011B79358F7, 0x4, Rax);
	SPOOF_OS_VER(0x00000011B7882717, 0x4, R8);
	SPOOF_OS_VER(0x00000011B7A579EF, 0x7, Rbx);
	SPOOF_OS_VER(0x00000011B7A4C069, 0x8, R10);
	SPOOF_OS_VER(0x00000011B7845D45, 0x8, Rcx);
	SPOOF_OS_VER(0x00000011B7A5A649, 0x8, Rdx);
	SPOOF_OS_VER(0x00000011B80C88EA, 0x7, Rcx);
	SPOOF_OS_VER(0x00000011B78BC7B7, 0x7, Rax);
	SPOOF_OS_VER(0x00000011B7659B11, 0x3, Rax);
	SPOOF_OS_VER(0x00000011B7AB15EF, 0x4, Rdx);
	SPOOF_OS_VER(0x00000011B810FD83, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B8040373, 0x3, Rdx);
	SPOOF_OS_VER(0x00000011B7F3D251, 0x7, Rsi);
	SPOOF_OS_VER(0x00000011B7804144, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B7C95A76, 0x4, R10);
	SPOOF_OS_VER(0x00000011B79E5EAB, 0x7, Rbx);
	SPOOF_OS_VER(0x00000011B7FFB829, 0x4, Rbp);
	SPOOF_OS_VER(0x00000011B78D5646, 0x3, Rdi);
	SPOOF_OS_VER(0x00000011B79F0872, 0x7, Rcx);
	SPOOF_OS_VER(0x00000011B77FE7CF, 0x7, Rax);
	SPOOF_OS_VER(0x00000011B7A31DB7, 0x8, Rdx);
	SPOOF_OS_VER(0x00000011B8059D87, 0x7, Rbp);
	SPOOF_OS_VER(0x00000011B7568CD5, 0x7, Rcx);
	SPOOF_OS_VER(0x00000011B7A353FA, 0x7, Rdi);
	SPOOF_OS_VER(0x00000011B78B140C, 0x8, Rax);
	SPOOF_OS_VER(0x00000011B792D978, 0x7, Rbx);
	SPOOF_OS_VER(0x00000011B79C7AB6, 0x7, Rdx);
	SPOOF_OS_VER(0x00000011B7AE046C, 0x7, Rax);
	SPOOF_OS_VER(0x00000011B79488FC, 0x8, R8);
	SPOOF_OS_VER(0x00000011B79696EC, 0x4, R8);
	return true;
}